å¹²å˜›çš„â“ ä½¿ç”¨WebGLæ¥ç»˜åˆ¶ä¸‰ç»´æ•ˆæžœã€‚
        å®ƒå¸®æˆ‘ä»¬å¤„ç†äº†åƒåœºæ™¯ã€ç¯å…‰ã€é˜´å½±ã€æè´¨ã€è´´å›¾ã€ç©ºé—´è¿ç®—ã€å‡ ä¹Žæ‰€æœ‰ä½ éœ€è¦è‡ªå·±é€šè¿‡WebGLæ¥å®žçŽ°çš„ä¸œè¥¿ã€‚


è¿‡ç¨‹â“
    1.åˆ›å»ºcanvasä¼ ç»™three.jsæ¥åˆ›å»ºrenderæ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({canvas});
    2.åˆ›å»ºä¸€ä¸ªæ‘„åƒæœº  
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    3.åˆ›å»ºä¸€ä¸ªåœºæ™¯ 
        (éœ€è¦threeç»˜åˆ¶çš„ä¸œè¥¿éƒ½è¦åŠ å…¥åˆ°sceneä¸­)
        const scene = new THREE.Scene()
    4.åˆ›å»ºä¸€ä¸ªåŒ…å«ç‰©ä½“ä¿¡æ¯çš„BoxGeometry
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
    5.åˆ›å»ºä¸€ä¸ªåŸºæœ¬çš„æè´¨ï¼Œè®¾ç½®é¢œè‰²ã€‚
        const material = new THREE.MeshBasicMaterial({color: #000000})
    6.åˆ›å»ºä¸€ä¸ªMesh
        Meshä»£è¡¨äº†Geometryå’ŒMaterialçš„ç»„åˆ, ä»¥åŠç‰©ä½“åœ¨åœºæ™¯ä¸­çš„ä½ç½®ã€æœå‘å’Œç¼©æ”¾ã€‚
        const cube = new THREE.Mesh(geometry, material)
    7.å°†Meshæ·»åŠ åˆ°åœºæ™¯ä¸­
        scene.add(cube)
    8.å°†sceneå’Œcameraä¼ é€’ç»™rendererçš„renderæ–¹æ³•æ¥æ¸²æŸ“æ•´ä¸ªåœºæ™¯
        renderer.render(scene,camera);
    
ðŸ‘†ä»¥ä¸Šä¸ºåŸºæœ¬è¿‡ç¨‹. æ­¤æ—¶åªä¼šçœ‹åˆ°ä¸‰ç»´å›¾å½¢çš„ä¸€ä¸ªé¢ã€‚
æ¥çœ‹çœ‹ä¸­é˜¶çŽ©æ³•ðŸ‘‡ï¼š

    1.æ·»åŠ  renderæ¸²æŸ“å‡½æ•°. è®©ä¸‰ç»´ç‰©ä½“åŠ¨èµ·æ¥
        function render(time){
            time *= 0.001;
            cube.rotation.x = cube.rotation.y = time;
            renderer.render(geometry,material);
            requestAnimationFrame(render);
        }    
    2.æ·»åŠ ç¯å…‰
        {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1,2,4);
            scene.add(light);
        }
        é™¤æ­¤ä¹‹å¤–è¿˜éœ€è¦å°†BacicMatierialå˜ä¸ºä¼šå—ç¯å…‰å½±å“çš„MeshPhongMaterial
        const material = new THREE.MeshPhongMaterial({color: 0x44aa88});
    3.åˆ›å»ºå¯ä»¥æ ¹æ®æŒ‡å®šé¢œè‰²ç”Ÿæˆæ–°æè´¨çš„å‡½æ•°
        function makeInstance(geometry,color,x){
            const material = new THREE.MeshPhongMaterial({color});
            const cube = new THREE.mesh(geometry,material);
            scene.add(cube);
            cube.position.x = x;
        }

æ‘„åƒæœºâ“
    å‡ ä¸ªæ¦‚å¿µï¼š
        1.fov: filed of view.
        2.aspect: æ˜¾ç¤ºæ¯”ä¾‹, å¦‚300Ã—150åƒç´ , aspectå€¼ä¸º300/150=2
        3.nearã€farï¼šæ‘„åƒæœºå‰æ–¹è¦æ¸²æŸ“çš„ç©ºé—´ã€‚
        soðŸ‘‰æˆåƒçš„é«˜åº¦ç”±fovå†³å®š, å®½åº¦ç”±fovå’Œaspectå…±åŒå†³å®š.


object3Dâ“
    just represents a local sapce.


è¾…åŠ©å·¥å…·â“ 
    1.// add an AxesHelper to each node  è¾…åŠ©çº¿
    objects.forEach((node) => {
    const axes = new THREE.AxesHelper();
    axes.material.depthTest = false;
    axes.renderOrder = 1;
    node.add(axes);
    });
    2.// both a GridHelper and an AxesHelper è¾…åŠ©çº¿+ç½‘æ ¼
    function makeAxisGrid(node, label, units) {
        const helper = new AxisGridHelper(node, units);
        gui.add(helper, 'visible').name(label);
    }
        
    makeAxisGrid(solarSystem, 'solarSystem', 25);
    makeAxisGrid(sunMesh, 'sunMesh');
    makeAxisGrid(earthOrbit, 'earthOrbit');
    makeAxisGrid(earthMesh, 'earthMesh');
    makeAxisGrid(moonMesh, 'moonMesh');